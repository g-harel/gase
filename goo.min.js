/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

const utils = () => {
    // type checks
    const isDefined = (value) => value !== undefined;
    const isNull = (value) => value === null;
    const isArray = (value) => Array.isArray(value);
    const isFunction = (value) => typeof value === 'function';
    const isString = (value) => typeof value === 'string';
    const isObject = (value) => (!!value) && (value.constructor === Object);
    const isNode = (value) => !!(value && value.tagName && value.nodeName && value.ownerDocument && value.removeAttribute);

    // creates a deep copy of an object (can only copy basic objects/arrays/primitives)
    const deepCopy = (obj) => {
        if (isArray(obj)) {
            return obj.map((element) => {
                return deepCopy(element);
            });
        }
        if (typeof obj === 'object' && obj) {
            const keys = Object.keys(obj);
            const temp = {};
            keys.forEach((key) => {
                temp[key] = deepCopy(obj[key]);
            });
            return temp;
        }
        return obj;
    };

    // displays error message
    const err = (message) => {
        throw(new Error(`gooErr:: ${message}`));
    };

    // throw errors when assertion fails
    const assert = (result, message, culprit) => {
        const print = (obj) => {
            return JSON.stringify(obj, (key, value) => {
                return (typeof value === 'function')
                    ? value.toString()
                    : value;
            }, 4);
        };
        if (!result) {
            err(message + (culprit?('\n>>>' + print(culprit)):'') || 'assertion has failed');
        }
    };

    // wait queue (ex. async middlware during blob changes)
    const makeQueue = () => {
        const queue = [];
        const run = () => {
            const func = queue[0];
            if (isDefined(func)) {
                func();
            }
        };
        const add = (func) => {
            assert(isFunction(func));
            queue.push(func);
            if (queue.length === 1) {
                run();
            }
        };
        const done = () => {
            queue.shift();
            run();
        };
        return {add, done};
    };

    // handle common blob logic
    const blobNames = {};
    const blobHandler = (blobs, blob = {}, queue) => {
        assert(isObject(blob), 'blob is not an object', blob);
        if (isDefined(blob.name)) {
            assert(isString(blob.name), 'a blob name must be a string', blob);
            if (blobNames[blob.name] === true) {
                return null;
            } else {
                blobNames[blob.name] = true;
            }
        }
        return Object.keys(blob).map((key) => {
            let blobObject = blob[key];
            if (!isArray(blobObject)) {
                blobObject = [blobObject];
            }
            if (!isDefined(blobs[key])) {
                return blobObject.map(() => null);
            }
            return blobObject.map((drop) => {
                if (isDefined(queue)) {
                    queue.add(() => {
                        blobs[key](drop);
                        queue.done();
                    });
                    return null;
                } else {
                    return blobs[key](drop);
                }
            });
        });
    };

    // public interface
    return {deepCopy, err, assert, isDefined, isNull, isArray, isFunction, isString, isObject, isNode, makeQueue, blobHandler};
};

module.exports = utils;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

const {assert, isDefined, isNull, isArray, isString, isNode, isObject, isFunction, makeQueue, blobHandler} = __webpack_require__(0)();

const dom = (_window = window, _target, _builder, _state) => {
    // build vdom from state
    const build = (state) => {
        const parse = (element) => {
            if (isNull(element)) {
                return {text: ''};
            }
            if (isString(element)) {
                return {text: element};
            }
            assert(isArray(element), 'vdom object is not an array or string', element);
            if (isFunction(element[0])) {
                let [, ...args] = element;
                return parse(element[0](...args));
            }
            let [tagType, attributes, children] = element;
            assert(isString(tagType), 'tag property is not a string', tagType);
            // capture groups: tagName, id, className, style
            const match = /^ *(\w+) *(?:#([-\w\d]+))? *((?:\.[-\w\d]+)*)? *(?:\|\s*([^\s]{1}[^]*?))? *$/.exec(tagType);
            assert(isArray(match), 'tag property cannot be parsed', tagType);
            let [, tagName, id, className, style] = match;
            if (!isObject(attributes)) {
                attributes = {};
            }
            if (isDefined(id) && !isDefined(attributes.id)) {
                attributes.id = id.trim();
            }
            if (isDefined(className)) {
                if (!isDefined(attributes.className)) {
                    attributes.className = '';
                }
                attributes.className += className.replace(/\./g, ' ');
                attributes.className = attributes.className.trim();
            }
            if (isDefined(style)) {
                if (!isDefined(attributes.style)) {
                    attributes.style = style;
                } else {
                    attributes.style += ';' + style;
                }
            }
            if (isDefined(children)) {
                assert(isArray(children), 'children of vdom object is not an array', children);
            } else {
                children = [];
            }
            return {
                tagName: tagName,
                attributes: attributes,
                children: children.map((c) => parse(c)),
            };
        };
        return parse(builder(state));
    };

    // recursively creates DOM elements from vdom object
    const render = (velem) => {
        if (isDefined(velem.text)) {
            velem.DOM = _window.document.createTextNode(velem.text);
            return velem;
        }
        const element = _window.document.createElement(velem.tagName);
        Object.keys(velem.attributes).forEach((attribute) => {
            element[attribute] = velem.attributes[attribute];
        });
        Object.keys(velem.children).forEach((key) => {
            velem.children[key] = render(velem.children[key]);
            element.appendChild(velem.children[key].DOM);
        });
        velem.DOM = element;
        return velem;
    };

    /* shallow diff of two objects which returns an array of the
        modified keys (functions always considered different)*/
    const diff = (original, successor) => {
        return Object.keys(Object.assign({}, original, successor)).filter((key) => {
            const valueOriginal = original[key];
            const valueSuccessor = successor[key];
            return !((valueOriginal !== Object(valueOriginal)) &&
                    (valueSuccessor !== Object(valueSuccessor)) &&
                    (valueOriginal === valueSuccessor));
        });
    };

    // update vdom and real DOM to new state
    const update = (newState) => {
        // using a queue to clean up deleted nodes after diffing finishes
        let queue = makeQueue();
        queue.add(() => {
            _window.requestAnimationFrame(() => _update(vdom, build(newState), {DOM: target, children: [vdom]}, 0));
            queue.done();
        });
        // recursive function to update an element according to new state
        const _update = (original, successor, originalParent, parentIndex) => {
            if (!isDefined(original) && !isDefined(successor)) {
                return;
            }
            // add
            if (!isDefined(original)) {
                originalParent.children[parentIndex] = render(successor);
                originalParent.DOM.appendChild(originalParent.children[parentIndex].DOM);
                return;
            }
            // remove
            if (!isDefined(successor)) {
                originalParent.DOM.removeChild(original.DOM);
                queue.add(() => {
                    delete originalParent.children[parentIndex];
                    queue.done();
                });
                return;
            }
            // replace
            if (original.tagName !== successor.tagName) {
                const oldDOM = original.DOM;
                const newVDOM = render(successor);
                originalParent.DOM.replaceChild(newVDOM.DOM, oldDOM);
                /* need to manually delete to preserve reference to past object */
                if (isDefined(newVDOM.text)) {
                    originalParent.children[parentIndex].DOM = newVDOM.DOM;
                    originalParent.children[parentIndex].text = newVDOM.text;
                    delete originalParent.children[parentIndex].tagName;
                    delete originalParent.children[parentIndex].attributes;
                    delete originalParent.children[parentIndex].children;
                } else {
                    originalParent.children[parentIndex].DOM = newVDOM.DOM;
                    delete originalParent.children[parentIndex].text;
                    originalParent.children[parentIndex].tagName = newVDOM.tagName;
                    originalParent.children[parentIndex].attributes = newVDOM.attributes;
                    originalParent.children[parentIndex].children = newVDOM.children;
                }
                return;
            }
            // edit
            if (original.DOM.nodeType === 3) {
                if (original.text !== successor.text) {
                    original.DOM.nodeValue = successor.text;
                    original.text = successor.text;
                }
            } else {
                const attributesDiff = diff(original.attributes, successor.attributes);
                if (attributesDiff.length !== 0) {
                    attributesDiff.forEach((key) => {
                        original.attributes[key] = successor.attributes[key];
                        original.DOM[key] = successor.attributes[key];
                    });
                }
            }
            const keys = (Object.keys(original.children || {}).concat(Object.keys(successor.children || {})));
            const visited = {};
            keys.forEach((key) => {
                if (visited[key] === undefined) {
                    visited[key] = true;
                    _update(original.children[key], successor.children[key], original, key);
                }
            });
        };
    };

    let vdom = render({text: ''});
    let target = undefined;
    let builder = undefined;
    let state = undefined;

    let hasDrawn = false;
    const drawToTarget = () => {
        hasDrawn = true;
        _window.requestAnimationFrame(() => {
            target.innerHTML = '';
            target.appendChild(vdom.DOM);
        });
    };

    const requiredVariablesAreDefined = () => {
        return isDefined(target) && isDefined(builder) && isDefined(state);
    };

    const replaceTarget = (newTarget) => {
        assert(isNode(newTarget), 'target is not a DOM node', newTarget);
        target = newTarget;
        if (requiredVariablesAreDefined()) {
            drawToTarget();
        }
    };

    const replaceBuilder = (newBuilder) => {
        assert(isFunction(newBuilder), 'builder is not a function', newBuilder);
        builder = newBuilder;
        if (requiredVariablesAreDefined()) {
            if (!hasDrawn) {
                drawToTarget();
            }
            update(state);
        }
    };

    const updateState = (newState) => {
        assert(isDefined(newState), 'new state is not defined', newState);
        state = newState;
        if (requiredVariablesAreDefined()) {
            if (!hasDrawn) {
                drawToTarget();
            }
            update(state);
        }
    };

    if (isDefined(_target)) {
        replaceTarget(_target);
    }
    if (isDefined(_builder)) {
        replaceBuilder(_builder);
    }
    if (isDefined(_state)) {
        updateState(_state);
    }

    const use = (blob) => {
        // making sure only one value is given to each handler
        const newBlob = {};
        Object.keys(blob).map((b) => newBlob[b] = [blob[b]]);
        if (isDefined(blob.name)) {
            newBlob.name = blob.name;
        }
        return blobHandler({
            target: replaceTarget,
            builder: replaceBuilder,
            state: updateState,
        }, newBlob);
    };

    return {use};
};

module.exports = dom;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

const {deepCopy} = __webpack_require__(0)();

const history = () => {
    let past = [];
    let current = {__unset__: true};
    let future = [];

    const historyLength = 20;
    const ignorePrefix = '*';

    const undoAction = {
        type: 'UNDO',
        target: [],
        handler: () => {
            if (past.length > 0 && (!past[past.length-1] || past[past.length-1].__unset__ !== true)) {
                future.push(current);
                return past.pop();
            } else {
                return current;
            }
        },
    };

    const redoAction = {
        type: 'REDO',
        target: [],
        handler: () => {
            if (future.length > 0) {
                past.push(current);
                return future.pop();
            } else {
                return current;
            }
        },
    };

    const updateState = (state, type) => {
        if (type[0] === ignorePrefix) {
            return;
        }
        if (type !== 'UNDO' && type !== 'REDO') {
            future = [];
            past.push(current);
            if (past.length > historyLength + 1) {
                past.shift();
            }
        }
        current = deepCopy(state);
    };

    return {
        action: [undoAction, redoAction],
        watcher: updateState,
    };
};

module.exports = history;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

const {deepCopy, assert, isDefined, isString, isObject, isFunction, blobHandler} = __webpack_require__(0)();

const paramKey = ':params';
const callbackKey = ':callback';

// creates blank single-level route object
const mkdir = () => {
    const temp = {};
    temp[paramKey] = {};
    return temp;
};

// splits url path into array
const explodePath = (path) => {
    return path
        .replace(/\?[^]*$/g, '')
        .split('/')
        .map((p) => p.trim());
};

const router = (_window = window) => {
    // store all the registered routes in an encoded format
    const pathStore = mkdir();

    // store base url to prepend to all addresses
    let baseUrl = '';

    let isHosted = _window.document.origin !== null && _window.document.origin !== 'null';

    // removes base url from a path
    let removeBaseUrl = (path) => {
        return path.replace(new RegExp('\^' + baseUrl), '') || '';
    };

    // fallback function
    let fallback = (path) => {
        console.log(`no route was found for\n>>>${path}`);
    };

    // store initial pathName
    let currentPath = _window.location.pathname;
    if (!isHosted) {
        currentPath = '';
    }

    // add a route/callback combo to the store given as argument
    const register = (store) => (path, callback) => {
        const explodedPath = explodePath(path);
        let currentLevel = store;
        explodedPath.forEach((token, i) => {
            if (token[0] === ':') {
                currentLevel[paramKey][token.substring(1)] =
                    currentLevel[paramKey][token.substring(1)] || [];
                let defaultObj = mkdir();
                currentLevel[paramKey][token.substring(1)].push(defaultObj);
                currentLevel = defaultObj;
            } else {
                currentLevel[token] = currentLevel[token] || mkdir();
                currentLevel = currentLevel[token];
            }
            if (i === explodedPath.length - 1) {
                currentLevel[callbackKey] = callback;
            }
        });
    };

    /* call all the callbacks from the store given as argument
        who's route matches path argument*/
    const fetch = (store) => (path, params) => {
        const explodedPath = explodePath(path);
        const explore = (fragment, path, params) => {
            path = path.slice();
            params = deepCopy(params);
            if (path.length === 0) {
                if (fragment[callbackKey]) {
                    fragment[callbackKey](params);
                    found = true;
                }
            } else {
                const next = path.shift();
                if (isDefined(fragment[next])) {
                    explore(fragment[next], path, params);
                }
                Object.keys(fragment[paramKey]).forEach((param) => {
                    fragment[paramKey][param].forEach((p) => {
                        let temp = {};
                        temp[param] = next;
                        explore(p, path, Object.assign(params, temp));
                    });
                });
            }
        };
        let found = false;
        explore(store, explodedPath, params);
        return found;
    };

    // handle back/forward events
    _window.onpopstate = () => {
        currentPath = removeBaseUrl(_window.location.pathname);
        let found = fetch(pathStore)(currentPath, _window.history.state || {});
        if (!found) {
            fallback(currentPath);
        }
    };

    // register wrapper that runs the current page's url against new routes
    const addRoute = ({path, callback}) => {
        assert(isString(path), 'register path is not a string', path);
        assert(isFunction(callback), `callback for path is not a function\n>>>${path}`, callback);
        register(pathStore)(path, callback);
        // chacking new path against current pathname
        const temp = mkdir();
        register(temp)(path, callback);
        fetch(temp)(currentPath, _window.history.state || {});
    };

    // replace the current fallback function
    const replaceFallback = (callback) => {
        assert(isFunction(callback), 'callback for fallback is not a function', callback);
        fallback = callback;
    };

    // fetch wrapper that makes the browser aware of the url change
    const redirect = (path, params = {}) => {
        assert(isString(path), 'redirect path is not a string', path);
        assert(isObject(params), 'redirect params is not an object', params);
        currentPath = path;
        if (isHosted) {
            /* edge doesn't care that the file is local and will allow pushState.
                it also includes "/C:" in the location.pathname, but adds it to
                the path given to pushState. which means it needs to be removed here */
            _window.history.pushState({}, '', (baseUrl + currentPath).replace(/^\/C\:/, ''));
        } else {
            console.log(`goo-router:: path changed to\n>>>${currentPath}`);
        }
        let found = fetch(pathStore)(currentPath, params);
        if (!found) {
            fallback(path);
        }
    };

    // replace the base url, adjust the current and try to fetch with the new url
    const replaceBaseUrl = (base) => {
        assert(isString(base), 'base url is not a string', base);
        baseUrl = base;
        currentPath = removeBaseUrl(currentPath);
        fetch(pathStore)(currentPath, _window.history.state || {});
    };

    const use = (blob) => {
        return blobHandler({
            route: addRoute,
            base: replaceBaseUrl,
            fallback: replaceFallback,
        }, blob);
    };

    return {redirect, use};
};

module.exports = router;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

const {assert, deepCopy, makeQueue, blobHandler, isDefined, isArray, isFunction, isString} = __webpack_require__(0)();

// creates an object that acts on a state
const state = () => {
    const actions = {};
    const middleware = [];
    const watchers = [];

    const queue = makeQueue();

    const addAction = (action) => {
        const {type, handler, target} = action;
        assert(isString(type), `@use>action: action type "${type}" is not a string`, action);
        assert(isFunction(handler), `@use>action: handler for action ${type} is not a function`, handler);
        assert(isArray(target), `@use>action: target of action ${type} is not an array`, target);
        target.forEach((address) => {
            assert(isString(address), `@use>action: target of action type ${type} is not an array of strings ${target}`);
        });
        if (actions[type] === undefined) {
            actions[type] = [action];
        } else {
            actions[type].push(action);
        }
    };

    const addMiddleware = (handler) => {
        assert(isFunction(handler), '@use>middleware: middleware is not a function', handler);
        middleware.push(handler);
    };

    const addWatcher = (handler) => {
        assert(isFunction(handler), '@use>watcher: watcher is not a function', handler);
        watchers.push(handler);
    };

    // supported blobs and their execution
    const use = (blob) => {
        return blobHandler({
            action: addAction,
            middleware: addMiddleware,
            watcher: addWatcher,
        }, blob, queue);
    };

    // exectute an action on the state
    const execute = (state, type, params) => {
        let newState = deepCopy(state);
        assert(isDefined(actions[type]), `action type '${type}' was not found`);
        actions[type].forEach((currentAction) => {
            let target = deepCopy(newState);
            if (currentAction.target.length > 0) {
                let reference = newState;
                currentAction.target.forEach((key, i, a) => {
                    assert(isDefined(target[key]), `target of action ${type} does not exist: @state.${currentAction.target.slice(0, i+1).join('.')}`);
                    if (i === a.length - 1) {
                        let newValue = currentAction.handler(target[key], params);
                        assert(isDefined(newValue), `result of action ${type} on target @state${currentAction.target[0]?'.':''}${currentAction.target.join('.')} is undefined`);
                        reference[key] = newValue;
                    } else {
                        target = target[key];
                        reference = reference[key];
                    }
                });
            } else {
                newState = currentAction.handler(target, params);
                assert(isDefined(newState), `result of action ${type} on target @state${currentAction.target[0]?'.':''}${currentAction.target.join('.')} is undefined`);
            }
        });

        watchers.forEach((watcher) => {
            watcher(deepCopy(newState), type, params);
        });

        queue.done();
    };

    // execute wrapper that applies middleware
    const apply = (state, type, params) => {
        const funcs = [(_state = state, _type = type, _params = params) => {
            execute(_state, _type, _params);
        }];
        middleware.reverse().forEach((currentMiddleware, index) => {
            funcs[index + 1] = (_state = state, _type = type, _params = params) => {
                state = _state;
                type = _type;
                params = _params;
                currentMiddleware(funcs[index], deepCopy(_state), _type, _params);
            };
        });
        funcs[middleware.length](deepCopy(state), type, params);
    };

    // apply wrapper that uses the wait queue
    const act = (state, type, params = {}) => {
        assert(isDefined(state), 'cannot call act with undefined state');
        assert(isDefined(type), 'cannot call act with undefined type');
        queue.add(() => {
            apply(state, type, params);
        });
    };

    return {act, use};
};

module.exports = state;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dom = __webpack_require__(1);
var state = __webpack_require__(4);
var router = __webpack_require__(3);
var history = __webpack_require__(2)();

var _require = __webpack_require__(0)(),
    isFunction = _require.isFunction,
    assert = _require.assert,
    deepCopy = _require.deepCopy;

var goo = function goo(rootElement) {
    var _window = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

    var domHandler = dom(_window, rootElement);
    var stateHandler = state();
    var routeHandler = router(_window);

    var _state = { __unset__: true };

    // forwarding use calls
    var use = function use(blob) {
        return [domHandler, stateHandler, routeHandler].map(function (g) {
            return g.use(blob);
        });
    };

    // adding blobs
    [history].forEach(function (b) {
        return use(b);
    });

    // add watcher to keep track of current state
    use({ watcher: function watcher(newState) {
            return _state = newState;
        }
    });

    // add watcher to update dom
    use({ watcher: function watcher(newState) {
            return use({ state: newState });
        }
    });

    // add action to override state
    use({ action: {
            type: '__OVERRIDE__',
            target: [],
            handler: function handler(target, params) {
                return params;
            }
        } });

    var update = function update() {
        use({ state: _state });
    };

    // adding currentState and forwarding act calls
    var act = function act(type, params) {
        assert(!(_state && _state.__unset__) || type === '__OVERRIDE__', 'cannot act on state before it has been set');
        if (isFunction(type)) {
            type();
            update();
            return;
        }
        stateHandler.act(_state, type, params);
    };

    // override state
    var setState = function setState(replacement) {
        act('__OVERRIDE__', isFunction(replacement) ? replacement(deepCopy(_state)) : replacement);
    };

    // register a route/controller combo
    var register = function register(path, builder) {
        if (isFunction(path)) {
            builder = path();
            use({ builder: builder });
            return;
        }
        use({ route: {
                path: path,
                callback: function callback(params) {
                    use({ builder: builder(params) });
                }
            } });
    };

    // making it easier to use undo/redo
    var undo = function undo() {
        act('UNDO', {});
    };
    var redo = function redo() {
        act('REDO', {});
    };

    var getState = function getState() {
        assert(!(_state && _state.__unset__), 'cannot get state before it has been set');
        return deepCopy(_state);
    };

    return Object.assign(register, {
        setState: setState,
        s: setState,
        getState: getState,
        g: getState,
        redirect: routeHandler.redirect,
        r: routeHandler.redirect,
        act: act,
        a: act,
        use: use,
        update: update,
        u: update,
        undo: undo,
        redo: redo
    });
};

// making goo function available as an import or in the global window object
if (typeof module !== 'undefined' && module.exports) {
    module.exports = goo;
}
if (!!window) {
    window.goo = goo;
}

/***/ })
/******/ ]);